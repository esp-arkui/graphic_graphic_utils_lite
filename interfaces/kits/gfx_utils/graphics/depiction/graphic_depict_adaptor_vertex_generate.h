/*
 * Copyright (c) 2020-2021 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @file graphic_geometry_depict_adaptor_vcgen.h
 *
 * @brief Defines Build geometry vertex generation process adapter
 * Use the coordinate conversion pipeline to change the vertices generated by the vertex source,
 * including coordinates, commands, generating new vertices, etc
 * @since 1.0
 * @version 1.0
 */

#ifndef GRAPHIC_GEOMETRY_DEPICT_ADAPTOR_VERTEX_GENERATE_INCLUDED
#define GRAPHIC_GEOMETRY_DEPICT_ADAPTOR_VERTEX_GENERATE_INCLUDED
#include <typeinfo>

#include "gfx_utils/graphics/common/graphic_common_basics.h"
#include "gfx_utils/graphics/vertexgenerate/graphic_vertex_generate_dash.h"

namespace OHOS {
    /**
     * @struct EmptyMarkers
     * @brief Build a default empty geometry structure
     * This structure is mainly used to set the default empty tag symbol for elements such as stroke
     * @see template<class VertexSource, class Markers = EmptyMarkers>
     * struct DepictStroke
     * @since 1.0
     * @version 1.0
     */
    struct EmptyMarkers {
        /**
         * @brief Clear all marker symbol elements
         * @since 1.0
         * @version 1.0
         */
        void RemoveAll()
        {}

        /**
         * @brief Add or insert marker symbol elements
         * @since 1.0
         * @version 1.0
         */
        void AddVertex(float, float, unsigned)
        {}

        /**
         * @brief Make relevant preparations before using this structure to build markers symbols
         * @since 1.0
         * @version 1.0
         */
        void PrepareSrc()
        {}

        /**
         * @brief A bunch of operation processing resets the new state
         * @since 1.0
         * @version 1.0
         */
        void Rewind(unsigned)
        {}

        /**
         * @brief Move vertices or generate new vertices according to different states
         * Return to the current operation status for subsequent processing
         * @since 1.0
         * @version 1.0
         */
        unsigned Vertex(float*, float*)
        {
            return PATH_CMD_STOP;
        }
    };

    /**
     * @template class DepictAdaptorVertexGenerator
     * @brief This template class is the base class of vertex generation adapter
     * It mainly uses the vertex construction and generation stage
     * Change the vertices generated by the vertex source,
     * including coordinates, commands, generating new vertices, etc.
     * template Parameters include vertex source, specific entity generator, marker symbol, etc
     * @since 1.0
     * @version 1.0
     */
    template <class VertexSource,
              class Generator,
              class Markers = EmptyMarkers>
    class DepictAdaptorVertexGenerator {
        /**
         * @brief Sets the state of the vertex adaptation generator
         * It basically includes initialization preparation,
         * cumulative generation of base points and generation of new point status of difference
         * @since 1.0
         * @version 1.0
         */
        enum VertexGeneratorEnum {
            INITIAL,
            ACCUMULATE,
            GENERATE
        };

    public:
        /**
         * @brief The constructor of the template class DepictAdaptorVertexGenerator
         * Initialize the vertex source class, and the collocated state is the initial state
         * @since 1.0
         * @version 1.0
         */
        explicit DepictAdaptorVertexGenerator(VertexSource& source)
            : m_source(&source), m_status(INITIAL)
        {}

        /**
         * @brief Set vertex source directly
         * @since 1.0
         * @version 1.0
         */
        void Attach(VertexSource& source)
        {
            m_source = &source;
        }

        /**
         * @brief Returns a variable generator reference
         * @since 1.0
         * @version 1.0
         */
        Generator& GetGenerator()
        {
            return m_generator;
        }

        /**
         * @brief Returns an immutable generator reference
         * @since 1.0
         * @version 1.0
         */
        const Generator& GetGenerator() const
        {
            return m_generator;
        }

        /**
         * @brief Returns a variable marker symbol reference
         * @since 1.0
         * @version 1.0
         */
        Markers& GetMarkers()
        {
            return m_markers;
        }

        /**
         * @brief Returns an immutable marker symbol reference
         * @since 1.0
         * @version 1.0
         */
        const Markers& GetMarkers() const
        {
            return m_markers;
        }

        /**
         * @brief Reset vertex state
         * @since 1.0
         * @version 1.0
         */
        void Rewind(unsigned path_id)
        {
            m_source->Rewind(path_id);
            m_status = INITIAL;
        }

        /**
         * @brief Move vertices or generate new vertices according to different states
         * Return to the current operation status for subsequent processing
         * @since 1.0
         * @version 1.0
         */
        unsigned Vertex(float* x, float* y);

    private:
        DepictAdaptorVertexGenerator(const DepictAdaptorVertexGenerator<VertexSource, Generator, Markers>&);
        const DepictAdaptorVertexGenerator<VertexSource, Generator, Markers>& operator=
        (const DepictAdaptorVertexGenerator<VertexSource, Generator, Markers>&);

        VertexSource* m_source;
        Generator m_generator;
        Markers m_markers;
        VertexGeneratorEnum m_status;
        unsigned m_last_cmd;
        float m_start_x;
        float m_start_y;
    };

    /**
     * @brief Move vertices or generate new vertices according to different states
     * Return to the current operation status for subsequent processing
     * @since 1.0
     * @version 1.0
     */
    template <class VertexSource, class Generator, class Markers>
    unsigned DepictAdaptorVertexGenerator<VertexSource, Generator, Markers>::Vertex(float* x, float* y)
    {
        unsigned cmd = PATH_CMD_STOP;
        bool done = false;
        while (!done) {
            switch (m_status) {
                case INITIAL:
                    m_last_cmd = m_source->Vertex(&m_start_x, &m_start_y);
                    m_markers.RemoveAll();
                    m_status = ACCUMULATE;
                    break;
                case ACCUMULATE:
                    if (IsStop(m_last_cmd))
                        return PATH_CMD_STOP;

                    m_markers.AddVertex(m_start_x, m_start_y, PATH_CMD_MOVE_TO);
#if GRAPHIC_GEOMETYR_ENABLE_DASH_GENERATE_VERTEX_SOURCE
                    m_generator.RemoveAll();
                    m_generator.AddVertex(m_start_x, m_start_y, PATH_CMD_MOVE_TO);

#else
                    if (typeid(m_generator) != typeid(VertexGenerateDash)) {
                        m_generator.RemoveAll();
                        m_generator.AddVertex(m_start_x, m_start_y, PATH_CMD_MOVE_TO);
                    }
#endif
                    while (1) {
                        cmd = m_source->Vertex(x, y);
                        if (IsVertex(cmd)) {
                            m_last_cmd = cmd;
                            if (IsMoveTo(cmd)) {
                                m_start_y = *y;
                                m_start_x = *x;
                                break;
                            }
                            m_markers.AddVertex(*x, *y, PATH_CMD_LINE_TO);
#if GRAPHIC_GEOMETYR_ENABLE_DASH_GENERATE_VERTEX_SOURCE
                            m_generator.AddVertex(*x, *y, cmd);
#else
                            if (typeid(m_generator) != typeid(VertexGenerateDash)) {
                                m_generator.AddVertex(*x, *y, cmd);
                            }
#endif
                        } else {
                            if (IsStop(cmd)) {
                                m_last_cmd = PATH_CMD_STOP;
                                break;
                            }
                            if (IsEndPoly(cmd)) {
#if GRAPHIC_GEOMETYR_ENABLE_DASH_GENERATE_VERTEX_SOURCE
                                m_generator.AddVertex(*x, *y, cmd);
#else
                                if (typeid(m_generator) != typeid(VertexGenerateDash)) {
                                    m_generator.AddVertex(*x, *y, cmd);
                                }

#endif
                                break;
                            }
                        }
                    }
                    if (typeid(m_generator) != typeid(VertexGenerateDash)) {
                        m_generator.Rewind(0);
                    }
                    m_status = GENERATE;
                    break;
                case GENERATE:
                    cmd = m_generator.Vertex(x, y);
                    if (IsStop(cmd)) {
                        m_status = ACCUMULATE;
                        break;
                    }
                    done = true;
                    break;
                default: break;
            }
        }
        return cmd;
    }
} // namespace OHOS
#endif
